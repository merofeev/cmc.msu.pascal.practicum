Судоку
=========
Требуется реализовать на языке Паскаль программу, решающую Судоку

Правила игры
----------------
> Источник [Википедия](https://ru.wikipedia.org/wiki/%D0%A1%D1%83%D0%B4%D0%BE%D0%BA%D1%83)

Игровое поле представляет собой квадрат размером 9×9, разделённый на меньшие квадраты со стороной в 3 клетки. Таким образом, всё игровое поле состоит из 81 клетки. В них уже в начале игры стоят некоторые числа (от 1 до 9), называемые подсказками. От игрока требуется заполнить свободные клетки цифрами от 1 до 9 так, чтобы в каждой строке, в каждом столбце и в каждом малом квадрате 3×3 каждая цифра встречалась бы только один раз.

[Пример реализации](http://sudoku.org.ua/rus/)

Требования к интерфейсу программы
-----------------------------------

1.  Программа запрашивает у пользователя, желает ли он использовать заранее определенную отладочную головоломку или хочет ввести свою
1. Согласно выбору пользователя программа загружает отладочную головоломку (см. раздел «Отладочная головоломка») или запрашивает у пользователя ввод головоломки
1. Ввод головоломки: полозователь построчно через пробел вводит начальное состояние игрового поля, обозначая пустые клетки с помощью `_`. Пример ввода пользователя содержится в разделе «Отладочная головоломка»
1. Программа печатает на экран решенную головоломку (если решений несколько, напечатать любое из них)

>Примечание:
>игровое поле должно печататься по строкам в виде, удобном для восприятия человеком.


Отладочная головоломка
-----------------------
Для удобства тестирования и отладки программа должна уметь загружать по запросу пользователя следующую начальную головоломку:

```
5 3 _ _ 7 _ _ _ _
6 _ _ 1 9 5 _ _ _
_ 9 8 _ _ _ _ 6 _
8 _ _ _ 6 _ _ _ 3
4 _ _ 8 _ 3 _ _ 1
7 _ _ _ 2 _ _ _ 6
_ 6 _ _ _ _ 2 8 _
_ _ _ 4 1 9 _ _ 5
_ _ _ _ 8 _ _ 7 9
```


Критерии оценки
-------------
|Задание                                                                | балл |
|-----------------------------------------------------------------------|------|
|Базовая часть                                                          |   10 |
|Возможность по выбору пользователя считать головоломку из файла        |   +2 |
|Возможность по выбору пользователя записать решение в файл             |   +2 |
|Печать всех решений головоломки                                        |   +2 |
|Печать не более чем `n` (задается пользователем) решений головоломки   |   +3 |
|Если решения не существует — печать соответсвующего сообщения          |   +1 |


Методические указания
------------

Игровое поле удобно хранить в виде массива слудующего типа
```Pascal
type
  Field = array[1..N][1..M] of integer;
```
или (если ваш компилятор не поддерживает такое объявление)
```Pascal
type
  line = array[1..M] of integer;
  Field = array[1..N] of line;
```

Обозначая нулем пустые клетки.

Алгоритм решения головоломки предлагается реализовать с использованием рекурсивной функции, которая, получив на вход некоторую расстановку чисел, находит пустую клетку, для которой существует наименьшее число допустимых вариантов заполнения, и вызывает сама себя для каждого из вариантов заполнения этой клетки. Если все игровое поле успешно заполнено — функция возвращет  `true` (предварительно сохранив или напечатав ответ), а если допустимых ходов нет — функция возвращает `false`.

Для выполнения ряда бонусных пунктов вам потребуются навыки работы с текстовыми файлами.
Для работы с текстовыми файлами в паскале имеется специальный тип `text`

Объявим переменную типа `text`
```Pascal
var inf:text;
```
Теперь свяжем ее с файлом на диске компьютера
```Pascal
assign(inf,'имя файла.txt');
```
Теперь нужно установить режим работы с файлом. `reset(inf)` подготовит файл для чтения; `rewrite(inf)` — для записи.

Дальнейшая работа с файлом очень похожа на уже знакомый вам ввод/вывод на экран. Для этого используются операторы `read` и `write`, первым аргументом которых является файл.
После завершения работы с файлом его нужно закрыть `close(inf)`

Например, скопируем целое число из файла `a.txt` в файл `b.txt`:
```Pascal
var
  i:integer;
  inf,ouf:text;
begin
  assign(inf,'a.txt');
  assign(ouf,'b.txt');

  reset(inf);
  rewrite(ouf);

  read(inf,i);
  write(ouf,i);

  close(inf);
  close(ouf);
end.
```
