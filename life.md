Игра «Жизнь»
=========
Требуется реализовать на языке Паскаль игру «Жизнь»

Правила игры
----------------
> Источник [Википедия](http://goo.gl/ILgiKq)


* Место действия этой игры — «вселенная» — это размеченная на клетки ограниченная плоскость
* Каждая клетка на этой плоскости может находиться в двух состояниях: быть «живой» или быть «мёртвой» (пустой).
* Клетка имеет восемь соседей (окружающих клеток).
* Распределение живых клеток в начале игры называется первым поколением. Каждое следующее поколение рассчитывается на основе предыдущего по таким правилам:
    * в пустой (мёртвой) клетке, рядом с которой ровно три живые клетки, зарождается жизнь;
    * если у живой клетки есть две или три живые соседки, то эта клетка продолжает жить; в противном случае (если соседей меньше двух или больше трёх) клетка умирает («от одиночества» или «от перенаселённости»).

[Пример реализации](http://goo.gl/ILgiKq)

Требования к интерфейсу программы
-----------------------------------

1.  Программа запрашивает у пользователя, желает ли он использовать заранее определенную отладочную конфигурацию живых клеток или хочет ввести свою
1. Согласно выбору пользователя программа загружает отладочную конфигурацию (см. раздел «Отладочная конфигурация») или запрашивает у пользователя ввод конфигурации
1. Ввод конфигурации: пользователь вводит ширину и высоту игрового поля (можно считать, что они меньше 100), затем построчно вводит поле, живые клетки обозначаются символом `#`, мертвые `_`.
1. Затем пользователь вводит натуральное число или символ `q`
1. Если пользователь ввел символ `q`, программа завершает свою работу, если пользователь ввел число, программа выполняет заданное число шагов, печатает возникшую конфигурацию и возвращается на прошлый шаг.

>Примечания:
>игровое поле должно печататься по строкам в виде, удобном для восприятия человеком.

Отладочная конфигурация
--------------
Для удобства тестирования и отладки программа должна уметь загружать по запросу пользователя следующую начальную конфигурацию:
```
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
___________________________#____________
________________________####____#_______
_______________#_______####_____#_______
______________#_#______#__#_________##__
_____________#___##____####_________##__
__##_________#___##_____####____________
__##_________#___##________#____________
______________#_#_______________________
_______________#________________________
________________________#_#_____________
_________________________##_____________
_________________________#______________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________#_______
_________________________________##_____
________________________________##______
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
________________________________________
```

Критерии оценки
-------------
|Задание                                         | балл |
|------------------------------------------------|------|
|Базовая часть                                   |   10 |
|возможность по выбору пользователя считать начальную конфигурацию из файла, формат которого совпадает с форматом ввода с клавиатуры| +2 |
|возможность по выбору пользователя записать текущую конфигурацию в файл | +2 |
|игровое поле свернуто в тор (левый край «сшит» с правым, верхний «сшит» с нижним)| +3 |
|предоставить пользователю возможность менять игровую конфигурацию в процессе игры с использованием команд вида `row_number col_number state`, где `row_number` и `col_number` — номера строчки и столбца соответственно, а `state`— это `_` чтобы «убить» клетку, или `#` чтобы «оживить»| +3 |

Методические указания
------------

Игровое поле удобно хранить в виде массива слудующего типа
```Pascal
type
  Field = array[1..N,1..M] of boolean;
```
или (если ваш компилятор не поддерживает такое объявление)
```Pascal
type
  line = array[1..M] of boolean;
  Field = array[1..N] of line;
```

Обозначая как `true` живые клетки, и как `false` мертвые

При вычислении новой игровой конфигурации важно, чтобы уже обновленные клетки не повлияли на остальные. Для этого перед началом обновления необходимо помещать текущую конфигурацию во временный массив.

Для выполнения ряда бонусных пунктов вам потребуются навыки работы с текстовыми файлами.
Для работы с текстовыми файлами в паскале имеется специальный тип `text`

Объявим переменную типа `text`
```Pascal
var inf:text;
```
Теперь свяжем ее с файлом на диске компьютера
```Pascal
assign(inf,'имя файла.txt');
```
Теперь нужно установить режим работы с файлом. `reset(inf)` подготовит файл для чтения; `rewrite(inf)` — для записи.

Дальнейшая работа с файлом очень похожа на уже знакомый вам ввод/вывод на экран. Для этого используются операторы `read` и `write`, первым аргументом которых является файл.
После завершения работы с файлом его нужно закрыть `close(inf)`

Например, скопируем целое число из файла `a.txt` в файл `b.txt`:
```Pascal
var
  i:integer;
  inf,ouf:text;
begin
  assign(inf,'a.txt');
  assign(ouf,'b.txt');

  reset(inf);
  rewrite(ouf);

  read(inf,i);
  write(ouf,i);

  close(inf);
  close(ouf);
end.
```
